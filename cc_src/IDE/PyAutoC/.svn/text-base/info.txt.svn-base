    class basestring(object)
     |  Type basestring cannot be instantiated; it is the base for str and unicode.
     |  
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1E1F70>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class bool(int)
     |  bool(x) -> bool
     |  
     |  Returns True when the argument x is true, False otherwise.
     |  The builtins True and False are the only two instances of the class bool.
     |  The class bool is a subclass of the class int, and cannot be subclassed.
     |  
     |  Method resolution order:
     |      bool
     |      int
     |      object
     |  
     |  Methods defined here:
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1C5DF8>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from int:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __coerce__(...)
     |      x.__coerce__(y) <==> coerce(x, y)
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getnewargs__(...)
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __hex__(...)
     |      x.__hex__() <==> hex(x)
     |  
     |  __index__(...)
     |      x[y:z] <==> x[y.__index__():z.__index__()]
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __invert__(...)
     |      x.__invert__() <==> ~x
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lshift__(...)
     |      x.__lshift__(y) <==> x<<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __oct__(...)
     |      x.__oct__() <==> oct(x)
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rlshift__(...)
     |      x.__rlshift__(y) <==> y<<x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rrshift__(...)
     |      x.__rrshift__(y) <==> y>>x
     |  
     |  __rshift__(...)
     |      x.__rshift__(y) <==> x>>y
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
    
    class buffer(object)
     |  buffer(object [, offset[, size]])
     |  
     |  Create a new buffer object which references the given object.
     |  The buffer will reference a slice of the target object from the
     |  start of the object (or at the specified offset). The slice will
     |  extend to the end of the target object (or with the specified size).
     |  
     |  Methods defined here:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __delslice__(...)
     |      x.__delslice__(i, j) <==> del x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  __setslice__(...)
     |      x.__setslice__(i, j, y) <==> x[i:j]=y
     |      
     |      Use  of negative indices is not supported.
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1C6030>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class classmethod(object)
     |  classmethod(function) -> method
     |  
     |  Convert a function to be a class method.
     |  
     |  A class method receives the class as implicit first argument,
     |  just like an instance method receives the instance.
     |  To declare a class method, use this idiom:
     |  
     |    class C:
     |        def f(cls, arg1, arg2, ...): ...
     |        f = classmethod(f)
     |  
     |  It can be called either on the class (e.g. C.f()) or on an instance
     |  (e.g. C().f()).  The instance is ignored except for its class.
     |  If a class method is called for a derived class, the derived class
     |  object is passed as the implied first argument.
     |  
     |  Class methods are different than C++ or Java static methods.
     |  If you want those, see the staticmethod builtin.
     |  
     |  Methods defined here:
     |  
     |  __get__(...)
     |      descr.__get__(obj[, type]) -> value
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D0098>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class complex(object)
     |  complex(real[, imag]) -> complex number
     |  
     |  Create a complex number from a real part and an optional imaginary part.
     |  This is equivalent to (real + imag*1j) where imag defaults to 0.
     |  
     |  Methods defined here:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __coerce__(...)
     |      x.__coerce__(y) <==> coerce(x, y)
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getnewargs__(...)
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
     |  
     |  conjugate(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  imag
     |      the imaginary part of a complex number
     |  
     |  real
     |      the real part of a complex number
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1C7D18>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class dict(object)
     |  dict() -> new empty dictionary.
     |  dict(mapping) -> new dictionary initialized from a mapping object's
     |      (key, value) pairs.
     |  dict(seq) -> new dictionary initialized as if via:
     |      d = {}
     |      for k, v in seq:
     |          d[k] = v
     |  dict(**kwargs) -> new dictionary initialized with the name=value pairs
     |      in the keyword argument list.  For example:  dict(one=1, two=2)
     |  
     |  Methods defined here:
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __contains__(...)
     |      D.__contains__(k) -> True if D has a key k, else False
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  get(...)
     |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
     |  
     |  has_key(...)
     |      D.has_key(k) -> True if D has a key k, else False
     |  
     |  items(...)
     |      D.items() -> list of D's (key, value) pairs, as 2-tuples
     |  
     |  iteritems(...)
     |      D.iteritems() -> an iterator over the (key, value) items of D
     |  
     |  iterkeys(...)
     |      D.iterkeys() -> an iterator over the keys of D
     |  
     |  itervalues(...)
     |      D.itervalues() -> an iterator over the values of D
     |  
     |  keys(...)
     |      D.keys() -> list of D's keys
     |  
     |  pop(...)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value
     |      If key is not found, d is returned if given, otherwise KeyError is raised
     |  
     |  popitem(...)
     |      D.popitem() -> (k, v), remove and return some (key, value) pair as a
     |      2-tuple; but raise KeyError if D is empty
     |  
     |  setdefault(...)
     |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
     |  
     |  update(...)
     |      D.update(E, **F) -> None.  Update D from E and F: for k in E: D[k] = E[k]
     |      (if E has keys else: for (k, v) in E: D[k] = v) then: for k in F: D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> list of D's values
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CB048>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  fromkeys = <built-in method fromkeys of type object at 0x1E1CB048>
     |      dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v.
     |      v defaults to None.
    
    class enumerate(object)
     |  enumerate(iterable) -> iterator for index, value of iterable
     |  
     |  Return an enumerate object.  iterable must be an other object that supports
     |  iteration.  The enumerate object yields pairs containing a count (from
     |  zero) and a value yielded by the iterable argument.  enumerate is useful
     |  for obtaining an indexed list: (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
     |  
     |  Methods defined here:
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  next(...)
     |      x.next() -> the next value, or raise StopIteration
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CB518>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class file(object)
     |  file(name[, mode[, buffering]]) -> file object
     |  
     |  Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),
     |  writing or appending.  The file will be created if it doesn't exist
     |  when opened for writing or appending; it will be truncated when
     |  opened for writing.  Add a 'b' to the mode for binary files.
     |  Add a '+' to the mode to allow simultaneous reading and writing.
     |  If the buffering argument is given, 0 means unbuffered, 1 means line
     |  buffered, and larger numbers specify the buffer size.
     |  Add a 'U' to mode to open the file for input with universal newline
     |  support.  Any line ending in the input file will be seen as a '\n'
     |  in Python.  Also, a file so opened gains the attribute 'newlines';
     |  the value for this attribute is one of None (no newline read yet),
     |  '\r', '\n', '\r\n' or a tuple containing all the newline types seen.
     |  
     |  'U' cannot be combined with 'w' or '+' mode.
     |  
     |  Methods defined here:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __enter__(...)
     |      __enter__() -> self.
     |  
     |  __exit__(...)
     |      __exit__(*excinfo) -> None.  Closes the file.
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  close(...)
     |      close() -> None or (perhaps) an integer.  Close the file.
     |      
     |      Sets data attribute .closed to True.  A closed file cannot be used for
     |      further I/O operations.  close() may be called more than once without
     |      error.  Some kinds of file objects (for example, opened by popen())
     |      may return an exit status upon closing.
     |  
     |  fileno(...)
     |      fileno() -> integer "file descriptor".
     |      
     |      This is needed for lower-level file interfaces, such os.read().
     |  
     |  flush(...)
     |      flush() -> None.  Flush the internal I/O buffer.
     |  
     |  isatty(...)
     |      isatty() -> true or false.  True if the file is connected to a tty device.
     |  
     |  next(...)
     |      x.next() -> the next value, or raise StopIteration
     |  
     |  read(...)
     |      read([size]) -> read at most size bytes, returned as a string.
     |      
     |      If the size argument is negative or omitted, read until EOF is reached.
     |      Notice that when in non-blocking mode, less data than what was requested
     |      may be returned, even if no size parameter was given.
     |  
     |  readinto(...)
     |      readinto() -> Undocumented.  Don't use this; it may go away.
     |  
     |  readline(...)
     |      readline([size]) -> next line from the file, as a string.
     |      
     |      Retain newline.  A non-negative size argument limits the maximum
     |      number of bytes to return (an incomplete line may be returned then).
     |      Return an empty string at EOF.
     |  
     |  readlines(...)
     |      readlines([size]) -> list of strings, each a line from the file.
     |      
     |      Call readline() repeatedly and return a list of the lines so read.
     |      The optional size argument, if given, is an approximate bound on the
     |      total number of bytes in the lines returned.
     |  
     |  seek(...)
     |      seek(offset[, whence]) -> None.  Move to new file position.
     |      
     |      Argument offset is a byte count.  Optional argument whence defaults to
     |      0 (offset from start of file, offset should be >= 0); other values are 1
     |      (move relative to current position, positive or negative), and 2 (move
     |      relative to end of file, usually negative, although many platforms allow
     |      seeking beyond the end of a file).  If the file is opened in text mode,
     |      only offsets returned by tell() are legal.  Use of other offsets causes
     |      undefined behavior.
     |      Note that not all file objects are seekable.
     |  
     |  tell(...)
     |      tell() -> current file position, an integer (may be a long integer).
     |  
     |  truncate(...)
     |      truncate([size]) -> None.  Truncate the file to at most size bytes.
     |      
     |      Size defaults to the current file position, as returned by tell().
     |  
     |  write(...)
     |      write(str) -> None.  Write string str to file.
     |      
     |      Note that due to buffering, flush() or close() may be needed before
     |      the file on disk reflects the data written.
     |  
     |  writelines(...)
     |      writelines(sequence_of_strings) -> None.  Write the strings to the file.
     |      
     |      Note that newlines are not added.  The sequence can be any iterable object
     |      producing strings. This is equivalent to calling write() for each string.
     |  
     |  xreadlines(...)
     |      xreadlines() -> returns self.
     |      
     |      For backward compatibility. File objects now include the performance
     |      optimizations previously implemented in the xreadlines module.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  closed
     |      True if the file is closed
     |  
     |  encoding
     |      file encoding
     |  
     |  mode
     |      file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)
     |  
     |  name
     |      file name
     |  
     |  newlines
     |      end-of-line convention used in this file
     |  
     |  softspace
     |      flag indicating that a space needs to be printed; used by print
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CF230>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class float(object)
     |  float(x) -> floating point number
     |  
     |  Convert a string or number to a floating point number, if possible.
     |  
     |  Methods defined here:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __coerce__(...)
     |      x.__coerce__(y) <==> coerce(x, y)
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getnewargs__(...)
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __getformat__ = <built-in method __getformat__ of type object at 0x1E1...
     |      float.__getformat__(typestr) -> string
     |      
     |      You probably don't want to use this function.  It exists mainly to be
     |      used in Python's test suite.
     |      
     |      typestr must be 'double' or 'float'.  This function returns whichever of
     |      'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the
     |      format of floating point numbers used by the C type named by typestr.
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CF798>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  __setformat__ = <built-in method __setformat__ of type object at 0x1E1...
     |      float.__setformat__(typestr, fmt) -> None
     |      
     |      You probably don't want to use this function.  It exists mainly to be
     |      used in Python's test suite.
     |      
     |      typestr must be 'double' or 'float'.  fmt must be one of 'unknown',
     |      'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be
     |      one of the latter two if it appears to match the underlying C reality.
     |      
     |      Overrides the automatic determination of C-level floating point type.
     |      This affects how floats are converted to and from binary strings.
    
    class frozenset(object)
     |  frozenset(iterable) --> frozenset object
     |  
     |  Build an immutable unordered collection of unique elements.
     |  
     |  Methods defined here:
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x.
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __reduce__(...)
     |      Return state information for pickling.
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  copy(...)
     |      Return a shallow copy of a set.
     |  
     |  difference(...)
     |      Return the difference of two sets as a new set.
     |      
     |      (i.e. all elements that are in this set but not the other.)
     |  
     |  intersection(...)
     |      Return the intersection of two sets as a new set.
     |      
     |      (i.e. all elements that are in both sets.)
     |  
     |  issubset(...)
     |      Report whether another set contains this set.
     |  
     |  issuperset(...)
     |      Report whether this set contains another set.
     |  
     |  symmetric_difference(...)
     |      Return the symmetric difference of two sets as a new set.
     |      
     |      (i.e. all elements that are in exactly one of the sets.)
     |  
     |  union(...)
     |      Return the union of two sets as a new set.
     |      
     |      (i.e. all elements that are in either set.)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1DE9C8>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class int(object)
     |  int(x[, base]) -> integer
     |  
     |  Convert a string or number to an integer, if possible.  A floating point
     |  argument will be truncated towards zero (this does not include a string
     |  representation of a floating point number!)  When converting a string, use
     |  the optional base.  It is an error to supply a base when converting a
     |  non-string. If the argument is outside the integer range a long object
     |  will be returned instead.
     |  
     |  Methods defined here:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __coerce__(...)
     |      x.__coerce__(y) <==> coerce(x, y)
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getnewargs__(...)
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __hex__(...)
     |      x.__hex__() <==> hex(x)
     |  
     |  __index__(...)
     |      x[y:z] <==> x[y.__index__():z.__index__()]
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __invert__(...)
     |      x.__invert__() <==> ~x
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lshift__(...)
     |      x.__lshift__(y) <==> x<<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __oct__(...)
     |      x.__oct__() <==> oct(x)
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rlshift__(...)
     |      x.__rlshift__(y) <==> y<<x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rrshift__(...)
     |      x.__rrshift__(y) <==> y>>x
     |  
     |  __rshift__(...)
     |      x.__rshift__(y) <==> x>>y
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D5600>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class list(object)
     |  list() -> new list
     |  list(sequence) -> new list initialized from sequence's items
     |  
     |  Methods defined here:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __delslice__(...)
     |      x.__delslice__(i, j) <==> del x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __iadd__(...)
     |      x.__iadd__(y) <==> x+=y
     |  
     |  __imul__(...)
     |      x.__imul__(y) <==> x*=y
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __reversed__(...)
     |      L.__reversed__() -- return a reverse iterator over the list
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  __setslice__(...)
     |      x.__setslice__(i, j, y) <==> x[i:j]=y
     |      
     |      Use  of negative indices is not supported.
     |  
     |  append(...)
     |      L.append(object) -- append object to end
     |  
     |  count(...)
     |      L.count(value) -> integer -- return number of occurrences of value
     |  
     |  extend(...)
     |      L.extend(iterable) -- extend list by appending elements from the iterable
     |  
     |  index(...)
     |      L.index(value, [start, [stop]]) -> integer -- return first index of value
     |  
     |  insert(...)
     |      L.insert(index, object) -- insert object before index
     |  
     |  pop(...)
     |      L.pop([index]) -> item -- remove and return item at index (default last)
     |  
     |  remove(...)
     |      L.remove(value) -- remove first occurrence of value
     |  
     |  reverse(...)
     |      L.reverse() -- reverse *IN PLACE*
     |  
     |  sort(...)
     |      L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
     |      cmp(x, y) -> -1, 0, 1
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D7AB8>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class long(object)
     |  long(x[, base]) -> integer
     |  
     |  Convert a string or number to a long integer, if possible.  A floating
     |  point argument will be truncated towards zero (this does not include a
     |  string representation of a floating point number!)  When converting a
     |  string, use the optional base.  It is an error to supply a base when
     |  converting a non-string.
     |  
     |  Methods defined here:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __coerce__(...)
     |      x.__coerce__(y) <==> coerce(x, y)
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getnewargs__(...)
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __hex__(...)
     |      x.__hex__() <==> hex(x)
     |  
     |  __index__(...)
     |      x[y:z] <==> x[y.__index__():z.__index__()]
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __invert__(...)
     |      x.__invert__() <==> ~x
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lshift__(...)
     |      x.__lshift__(y) <==> x<<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __oct__(...)
     |      x.__oct__() <==> oct(x)
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rlshift__(...)
     |      x.__rlshift__(y) <==> y<<x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rrshift__(...)
     |      x.__rrshift__(y) <==> y>>x
     |  
     |  __rshift__(...)
     |      x.__rshift__(y) <==> x>>y
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D8398>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class object
     |  The most base type
    
    class property(object)
     |  property(fget=None, fset=None, fdel=None, doc=None) -> property attribute
     |  
     |  fget is a function to be used for getting an attribute value, and likewise
     |  fset is a function for setting, and fdel a function for del'ing, an
     |  attribute.  Typical use is to define a managed attribute x:
     |  class C(object):
     |      def getx(self): return self.__x
     |      def setx(self, value): self.__x = value
     |      def delx(self): del self.__x
     |      x = property(getx, setx, delx, "I'm the 'x' property.")
     |  
     |  Methods defined here:
     |  
     |  __delete__(...)
     |      descr.__delete__(obj)
     |  
     |  __get__(...)
     |      descr.__get__(obj[, type]) -> value
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __set__(...)
     |      descr.__set__(obj, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  fdel
     |  
     |  fget
     |  
     |  fset
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CA838>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class reversed(object)
     |  reversed(sequence) -> reverse iterator over values of the sequence
     |  
     |  Return a reverse iterator
     |  
     |  Methods defined here:
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __length_hint__(...)
     |      Private method returning an estimate of len(list(it)).
     |  
     |  next(...)
     |      x.next() -> the next value, or raise StopIteration
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1CB690>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class set(object)
     |  set(iterable) --> set object
     |  
     |  Build an unordered collection of unique elements.
     |  
     |  Methods defined here:
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x.
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __iand__(...)
     |      x.__iand__(y) <==> x&y
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __ior__(...)
     |      x.__ior__(y) <==> x|y
     |  
     |  __isub__(...)
     |      x.__isub__(y) <==> x-y
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __ixor__(...)
     |      x.__ixor__(y) <==> x^y
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __reduce__(...)
     |      Return state information for pickling.
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  add(...)
     |      Add an element to a set.
     |      
     |      This has no effect if the element is already present.
     |  
     |  clear(...)
     |      Remove all elements from this set.
     |  
     |  copy(...)
     |      Return a shallow copy of a set.
     |  
     |  difference(...)
     |      Return the difference of two sets as a new set.
     |      
     |      (i.e. all elements that are in this set but not the other.)
     |  
     |  difference_update(...)
     |      Remove all elements of another set from this set.
     |  
     |  discard(...)
     |      Remove an element from a set if it is a member.
     |      
     |      If the element is not a member, do nothing.
     |  
     |  intersection(...)
     |      Return the intersection of two sets as a new set.
     |      
     |      (i.e. all elements that are in both sets.)
     |  
     |  intersection_update(...)
     |      Update a set with the intersection of itself and another.
     |  
     |  issubset(...)
     |      Report whether another set contains this set.
     |  
     |  issuperset(...)
     |      Report whether this set contains another set.
     |  
     |  pop(...)
     |      Remove and return an arbitrary set element.
     |  
     |  remove(...)
     |      Remove an element from a set; it must be a member.
     |      
     |      If the element is not a member, raise a KeyError.
     |  
     |  symmetric_difference(...)
     |      Return the symmetric difference of two sets as a new set.
     |      
     |      (i.e. all elements that are in exactly one of the sets.)
     |  
     |  symmetric_difference_update(...)
     |      Update a set with the symmetric difference of itself and another.
     |  
     |  union(...)
     |      Return the union of two sets as a new set.
     |      
     |      (i.e. all elements that are in either set.)
     |  
     |  update(...)
     |      Update a set with the union of itself and another.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1DE760>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class slice(object)
     |  slice([start,] stop[, step])
     |  
     |  Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).
     |  
     |  Methods defined here:
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  indices(...)
     |      S.indices(len) -> (start, stop, stride)
     |      
     |      Assuming a sequence of length len, calculate the start and stop
     |      indices, and the stride length of the extended slice described by
     |      S. Out of bounds indices are clipped in a manner consistent with the
     |      handling of normal slices.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  start
     |  
     |  step
     |  
     |  stop
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1DFE18>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class staticmethod(object)
     |  staticmethod(function) -> method
     |  
     |  Convert a function to be a static method.
     |  
     |  A static method does not receive an implicit first argument.
     |  To declare a static method, use this idiom:
     |  
     |       class C:
     |           def f(arg1, arg2, ...): ...
     |           f = staticmethod(f)
     |  
     |  It can be called either on the class (e.g. C.f()) or on an instance
     |  (e.g. C().f()).  The instance is ignored except for its class.
     |  
     |  Static methods in Python are similar to those found in Java or C++.
     |  For a more advanced concept, see the classmethod builtin.
     |  
     |  Methods defined here:
     |  
     |  __get__(...)
     |      descr.__get__(obj[, type]) -> value
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D0360>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class str(basestring)
     |  str(object) -> string
     |  
     |  Return a nice string representation of the object.
     |  If the argument is a string, the return value is the same object.
     |  
     |  Method resolution order:
     |      str
     |      basestring
     |      object
     |  
     |  Methods defined here:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getnewargs__(...)
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  capitalize(...)
     |      S.capitalize() -> string
     |      
     |      Return a copy of the string S with only its first character
     |      capitalized.
     |  
     |  center(...)
     |      S.center(width[, fillchar]) -> string
     |      
     |      Return S centered in a string of length width. Padding is
     |      done using the specified fill character (default is a space)
     |  
     |  count(...)
     |      S.count(sub[, start[, end]]) -> int
     |      
     |      Return the number of non-overlapping occurrences of substring sub in
     |      string S[start:end].  Optional arguments start and end are interpreted
     |      as in slice notation.
     |  
     |  decode(...)
     |      S.decode([encoding[,errors]]) -> object
     |      
     |      Decodes S using the codec registered for encoding. encoding defaults
     |      to the default encoding. errors may be given to set a different error
     |      handling scheme. Default is 'strict' meaning that encoding errors raise
     |      a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
     |      as well as any other name registerd with codecs.register_error that is
     |      able to handle UnicodeDecodeErrors.
     |  
     |  encode(...)
     |      S.encode([encoding[,errors]]) -> object
     |      
     |      Encodes S using the codec registered for encoding. encoding defaults
     |      to the default encoding. errors may be given to set a different error
     |      handling scheme. Default is 'strict' meaning that encoding errors raise
     |      a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
     |      'xmlcharrefreplace' as well as any other name registered with
     |      codecs.register_error that is able to handle UnicodeEncodeErrors.
     |  
     |  endswith(...)
     |      S.endswith(suffix[, start[, end]]) -> bool
     |      
     |      Return True if S ends with the specified suffix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      suffix can also be a tuple of strings to try.
     |  
     |  expandtabs(...)
     |      S.expandtabs([tabsize]) -> string
     |      
     |      Return a copy of S where all tab characters are expanded using spaces.
     |      If tabsize is not given, a tab size of 8 characters is assumed.
     |  
     |  find(...)
     |      S.find(sub [,start [,end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found,
     |      such that sub is contained within s[start,end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  index(...)
     |      S.index(sub [,start [,end]]) -> int
     |      
     |      Like S.find() but raise ValueError when the substring is not found.
     |  
     |  isalnum(...)
     |      S.isalnum() -> bool
     |      
     |      Return True if all characters in S are alphanumeric
     |      and there is at least one character in S, False otherwise.
     |  
     |  isalpha(...)
     |      S.isalpha() -> bool
     |      
     |      Return True if all characters in S are alphabetic
     |      and there is at least one character in S, False otherwise.
     |  
     |  isdigit(...)
     |      S.isdigit() -> bool
     |      
     |      Return True if all characters in S are digits
     |      and there is at least one character in S, False otherwise.
     |  
     |  islower(...)
     |      S.islower() -> bool
     |      
     |      Return True if all cased characters in S are lowercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  isspace(...)
     |      S.isspace() -> bool
     |      
     |      Return True if all characters in S are whitespace
     |      and there is at least one character in S, False otherwise.
     |  
     |  istitle(...)
     |      S.istitle() -> bool
     |      
     |      Return True if S is a titlecased string and there is at least one
     |      character in S, i.e. uppercase characters may only follow uncased
     |      characters and lowercase characters only cased ones. Return False
     |      otherwise.
     |  
     |  isupper(...)
     |      S.isupper() -> bool
     |      
     |      Return True if all cased characters in S are uppercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  join(...)
     |      S.join(sequence) -> string
     |      
     |      Return a string which is the concatenation of the strings in the
     |      sequence.  The separator between elements is S.
     |  
     |  ljust(...)
     |      S.ljust(width[, fillchar]) -> string
     |      
     |      Return S left justified in a string of length width. Padding is
     |      done using the specified fill character (default is a space).
     |  
     |  lower(...)
     |      S.lower() -> string
     |      
     |      Return a copy of the string S converted to lowercase.
     |  
     |  lstrip(...)
     |      S.lstrip([chars]) -> string or unicode
     |      
     |      Return a copy of the string S with leading whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is unicode, S will be converted to unicode before stripping
     |  
     |  partition(...)
     |      S.partition(sep) -> (head, sep, tail)
     |      
     |      Searches for the separator sep in S, and returns the part before it,
     |      the separator itself, and the part after it.  If the separator is not
     |      found, returns S and two empty strings.
     |  
     |  replace(...)
     |      S.replace (old, new[, count]) -> string
     |      
     |      Return a copy of string S with all occurrences of substring
     |      old replaced by new.  If the optional argument count is
     |      given, only the first count occurrences are replaced.
     |  
     |  rfind(...)
     |      S.rfind(sub [,start [,end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within s[start,end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  rindex(...)
     |      S.rindex(sub [,start [,end]]) -> int
     |      
     |      Like S.rfind() but raise ValueError when the substring is not found.
     |  
     |  rjust(...)
     |      S.rjust(width[, fillchar]) -> string
     |      
     |      Return S right justified in a string of length width. Padding is
     |      done using the specified fill character (default is a space)
     |  
     |  rpartition(...)
     |      S.rpartition(sep) -> (tail, sep, head)
     |      
     |      Searches for the separator sep in S, starting at the end of S, and returns
     |      the part before it, the separator itself, and the part after it.  If the
     |      separator is not found, returns two empty strings and S.
     |  
     |  rsplit(...)
     |      S.rsplit([sep [,maxsplit]]) -> list of strings
     |      
     |      Return a list of the words in the string S, using sep as the
     |      delimiter string, starting at the end of the string and working
     |      to the front.  If maxsplit is given, at most maxsplit splits are
     |      done. If sep is not specified or is None, any whitespace string
     |      is a separator.
     |  
     |  rstrip(...)
     |      S.rstrip([chars]) -> string or unicode
     |      
     |      Return a copy of the string S with trailing whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is unicode, S will be converted to unicode before stripping
     |  
     |  split(...)
     |      S.split([sep [,maxsplit]]) -> list of strings
     |      
     |      Return a list of the words in the string S, using sep as the
     |      delimiter string.  If maxsplit is given, at most maxsplit
     |      splits are done. If sep is not specified or is None, any
     |      whitespace string is a separator.
     |  
     |  splitlines(...)
     |      S.splitlines([keepends]) -> list of strings
     |      
     |      Return a list of the lines in S, breaking at line boundaries.
     |      Line breaks are not included in the resulting list unless keepends
     |      is given and true.
     |  
     |  startswith(...)
     |      S.startswith(prefix[, start[, end]]) -> bool
     |      
     |      Return True if S starts with the specified prefix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      prefix can also be a tuple of strings to try.
     |  
     |  strip(...)
     |      S.strip([chars]) -> string or unicode
     |      
     |      Return a copy of the string S with leading and trailing
     |      whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is unicode, S will be converted to unicode before stripping
     |  
     |  swapcase(...)
     |      S.swapcase() -> string
     |      
     |      Return a copy of the string S with uppercase characters
     |      converted to lowercase and vice versa.
     |  
     |  title(...)
     |      S.title() -> string
     |      
     |      Return a titlecased version of S, i.e. words start with uppercase
     |      characters, all remaining cased characters have lowercase.
     |  
     |  translate(...)
     |      S.translate(table [,deletechars]) -> string
     |      
     |      Return a copy of the string S, where all characters occurring
     |      in the optional argument deletechars are removed, and the
     |      remaining characters have been mapped through the given
     |      translation table, which must be a string of length 256.
     |  
     |  upper(...)
     |      S.upper() -> string
     |      
     |      Return a copy of the string S converted to uppercase.
     |  
     |  zfill(...)
     |      S.zfill(width) -> string
     |      
     |      Pad a numeric string S with zeros on the left, to fill a field
     |      of the specified width.  The string S is never truncated.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1E20C0>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class super(object)
     |  super(type) -> unbound super object
     |  super(type, obj) -> bound super object; requires isinstance(obj, type)
     |  super(type, type2) -> bound super object; requires issubclass(type2, type)
     |  Typical use to call a cooperative superclass method:
     |  class C(B):
     |      def meth(self, arg):
     |          super(C, self).meth(arg)
     |  
     |  Methods defined here:
     |  
     |  __get__(...)
     |      descr.__get__(obj[, type]) -> value
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __self__
     |      the instance invoking super(); may be None
     |  
     |  __self_class__
     |      the type of the instance invoking super(); may be None
     |  
     |  __thisclass__
     |      the class invoking super()
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1E8CA0>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class tuple(object)
     |  tuple() -> an empty tuple
     |  tuple(sequence) -> tuple initialized from sequence's items
     |  
     |  If the argument is a tuple, the return value is the same object.
     |  
     |  Methods defined here:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getnewargs__(...)
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1E7A10>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class type(object)
     |  type(object) -> the object's type
     |  type(name, bases, dict) -> a new type
     |  
     |  Methods defined here:
     |  
     |  __call__(...)
     |      x.__call__(...) <==> x(...)
     |  
     |  __cmp__(...)
     |      x.__cmp__(y) <==> cmp(x,y)
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __subclasses__(...)
     |      __subclasses__() -> list of immediate subclasses
     |  
     |  mro(...)
     |      mro() -> list
     |      return a type's method resolution order
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __base__
     |  
     |  __bases__
     |  
     |  __basicsize__
     |  
     |  __dict__
     |  
     |  __dictoffset__
     |  
     |  __flags__
     |  
     |  __itemsize__
     |  
     |  __mro__
     |  
     |  __weakrefoffset__
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1E7E18>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class unicode(basestring)
     |  unicode(string [, encoding[, errors]]) -> object
     |  
     |  Create a new Unicode object from the given encoded string.
     |  encoding defaults to the current default string encoding.
     |  errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.
     |  
     |  Method resolution order:
     |      unicode
     |      basestring
     |      object
     |  
     |  Methods defined here:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getnewargs__(...)
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  capitalize(...)
     |      S.capitalize() -> unicode
     |      
     |      Return a capitalized version of S, i.e. make the first character
     |      have upper case.
     |  
     |  center(...)
     |      S.center(width[, fillchar]) -> unicode
     |      
     |      Return S centered in a Unicode string of length width. Padding is
     |      done using the specified fill character (default is a space)
     |  
     |  count(...)
     |      S.count(sub[, start[, end]]) -> int
     |      
     |      Return the number of non-overlapping occurrences of substring sub in
     |      Unicode string S[start:end].  Optional arguments start and end are
     |      interpreted as in slice notation.
     |  
     |  decode(...)
     |      S.decode([encoding[,errors]]) -> string or unicode
     |      
     |      Decodes S using the codec registered for encoding. encoding defaults
     |      to the default encoding. errors may be given to set a different error
     |      handling scheme. Default is 'strict' meaning that encoding errors raise
     |      a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
     |      as well as any other name registerd with codecs.register_error that is
     |      able to handle UnicodeDecodeErrors.
     |  
     |  encode(...)
     |      S.encode([encoding[,errors]]) -> string or unicode
     |      
     |      Encodes S using the codec registered for encoding. encoding defaults
     |      to the default encoding. errors may be given to set a different error
     |      handling scheme. Default is 'strict' meaning that encoding errors raise
     |      a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
     |      'xmlcharrefreplace' as well as any other name registered with
     |      codecs.register_error that can handle UnicodeEncodeErrors.
     |  
     |  endswith(...)
     |      S.endswith(suffix[, start[, end]]) -> bool
     |      
     |      Return True if S ends with the specified suffix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      suffix can also be a tuple of strings to try.
     |  
     |  expandtabs(...)
     |      S.expandtabs([tabsize]) -> unicode
     |      
     |      Return a copy of S where all tab characters are expanded using spaces.
     |      If tabsize is not given, a tab size of 8 characters is assumed.
     |  
     |  find(...)
     |      S.find(sub [,start [,end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found,
     |      such that sub is contained within s[start,end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  index(...)
     |      S.index(sub [,start [,end]]) -> int
     |      
     |      Like S.find() but raise ValueError when the substring is not found.
     |  
     |  isalnum(...)
     |      S.isalnum() -> bool
     |      
     |      Return True if all characters in S are alphanumeric
     |      and there is at least one character in S, False otherwise.
     |  
     |  isalpha(...)
     |      S.isalpha() -> bool
     |      
     |      Return True if all characters in S are alphabetic
     |      and there is at least one character in S, False otherwise.
     |  
     |  isdecimal(...)
     |      S.isdecimal() -> bool
     |      
     |      Return True if there are only decimal characters in S,
     |      False otherwise.
     |  
     |  isdigit(...)
     |      S.isdigit() -> bool
     |      
     |      Return True if all characters in S are digits
     |      and there is at least one character in S, False otherwise.
     |  
     |  islower(...)
     |      S.islower() -> bool
     |      
     |      Return True if all cased characters in S are lowercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  isnumeric(...)
     |      S.isnumeric() -> bool
     |      
     |      Return True if there are only numeric characters in S,
     |      False otherwise.
     |  
     |  isspace(...)
     |      S.isspace() -> bool
     |      
     |      Return True if all characters in S are whitespace
     |      and there is at least one character in S, False otherwise.
     |  
     |  istitle(...)
     |      S.istitle() -> bool
     |      
     |      Return True if S is a titlecased string and there is at least one
     |      character in S, i.e. upper- and titlecase characters may only
     |      follow uncased characters and lowercase characters only cased ones.
     |      Return False otherwise.
     |  
     |  isupper(...)
     |      S.isupper() -> bool
     |      
     |      Return True if all cased characters in S are uppercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  join(...)
     |      S.join(sequence) -> unicode
     |      
     |      Return a string which is the concatenation of the strings in the
     |      sequence.  The separator between elements is S.
     |  
     |  ljust(...)
     |      S.ljust(width[, fillchar]) -> int
     |      
     |      Return S left justified in a Unicode string of length width. Padding is
     |      done using the specified fill character (default is a space).
     |  
     |  lower(...)
     |      S.lower() -> unicode
     |      
     |      Return a copy of the string S converted to lowercase.
     |  
     |  lstrip(...)
     |      S.lstrip([chars]) -> unicode
     |      
     |      Return a copy of the string S with leading whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is a str, it will be converted to unicode before stripping
     |  
     |  partition(...)
     |      S.partition(sep) -> (head, sep, tail)
     |      
     |      Searches for the separator sep in S, and returns the part before it,
     |      the separator itself, and the part after it.  If the separator is not
     |      found, returns S and two empty strings.
     |  
     |  replace(...)
     |      S.replace (old, new[, maxsplit]) -> unicode
     |      
     |      Return a copy of S with all occurrences of substring
     |      old replaced by new.  If the optional argument maxsplit is
     |      given, only the first maxsplit occurrences are replaced.
     |  
     |  rfind(...)
     |      S.rfind(sub [,start [,end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within s[start,end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  rindex(...)
     |      S.rindex(sub [,start [,end]]) -> int
     |      
     |      Like S.rfind() but raise ValueError when the substring is not found.
     |  
     |  rjust(...)
     |      S.rjust(width[, fillchar]) -> unicode
     |      
     |      Return S right justified in a Unicode string of length width. Padding is
     |      done using the specified fill character (default is a space).
     |  
     |  rpartition(...)
     |      S.rpartition(sep) -> (tail, sep, head)
     |      
     |      Searches for the separator sep in S, starting at the end of S, and returns
     |      the part before it, the separator itself, and the part after it.  If the
     |      separator is not found, returns two empty strings and S.
     |  
     |  rsplit(...)
     |      S.rsplit([sep [,maxsplit]]) -> list of strings
     |      
     |      Return a list of the words in S, using sep as the
     |      delimiter string, starting at the end of the string and
     |      working to the front.  If maxsplit is given, at most maxsplit
     |      splits are done. If sep is not specified, any whitespace string
     |      is a separator.
     |  
     |  rstrip(...)
     |      S.rstrip([chars]) -> unicode
     |      
     |      Return a copy of the string S with trailing whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is a str, it will be converted to unicode before stripping
     |  
     |  split(...)
     |      S.split([sep [,maxsplit]]) -> list of strings
     |      
     |      Return a list of the words in S, using sep as the
     |      delimiter string.  If maxsplit is given, at most maxsplit
     |      splits are done. If sep is not specified or is None,
     |      any whitespace string is a separator.
     |  
     |  splitlines(...)
     |      S.splitlines([keepends]]) -> list of strings
     |      
     |      Return a list of the lines in S, breaking at line boundaries.
     |      Line breaks are not included in the resulting list unless keepends
     |      is given and true.
     |  
     |  startswith(...)
     |      S.startswith(prefix[, start[, end]]) -> bool
     |      
     |      Return True if S starts with the specified prefix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      prefix can also be a tuple of strings to try.
     |  
     |  strip(...)
     |      S.strip([chars]) -> unicode
     |      
     |      Return a copy of the string S with leading and trailing
     |      whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |      If chars is a str, it will be converted to unicode before stripping
     |  
     |  swapcase(...)
     |      S.swapcase() -> unicode
     |      
     |      Return a copy of S with uppercase characters converted to lowercase
     |      and vice versa.
     |  
     |  title(...)
     |      S.title() -> unicode
     |      
     |      Return a titlecased version of S, i.e. words start with title case
     |      characters, all remaining cased characters have lower case.
     |  
     |  translate(...)
     |      S.translate(table) -> unicode
     |      
     |      Return a copy of the string S, where all characters have been mapped
     |      through the given translation table, which must be a mapping of
     |      Unicode ordinals to Unicode ordinals, Unicode strings or None.
     |      Unmapped characters are left untouched. Characters mapped to None
     |      are deleted.
     |  
     |  upper(...)
     |      S.upper() -> unicode
     |      
     |      Return a copy of S converted to uppercase.
     |  
     |  zfill(...)
     |      S.zfill(width) -> unicode
     |      
     |      Pad a numeric string x with zeros on the left, to fill a field
     |      of the specified width. The string x is never truncated.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1F0E08>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class xrange(object)
     |  xrange([start,] stop[, step]) -> xrange object
     |  
     |  Like range(), but instead of returning a list, returns an object that
     |  generates the numbers in the range on demand.  For looping, this is 
     |  slightly faster than range() and more memory efficient.
     |  
     |  Methods defined here:
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __reversed__(...)
     |      Returns a reverse iterator.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1DDD10>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T

    import(...)
        import(name, globals={}, locals={}, fromlist=[], level=-1) -> module
        
        Import a module.  The globals are only used to determine the context;
        they are not modified.  The locals are currently unused.  The fromlist
        should be a list of names to emulate ``from name import ...'', or an
        empty list to emulate ``import name''.
        When importing a module from a package, note that __import__('A.B', ...)
        returns package A when fromlist is empty, but its submodule B when
        fromlist is not empty.  Level is used to determine whether to perform 
        absolute or relative imports.  -1 is the original strategy of attempting
        both absolute and relative imports, 0 is absolute, a positive number
        is the number of parent directories to search relative to the current module.
    
    abs(...)
        abs(number) -> number
        
        Return the absolute value of the argument.
    
    all(...)
        all(iterable) -> bool
        
        Return True if bool(x) is True for all values x in the iterable.
    
    any(...)
        any(iterable) -> bool
        
        Return True if bool(x) is True for any x in the iterable.
    
    apply(...)
        apply(object[, args[, kwargs]]) -> value
        
        Call a callable object with positional arguments taken from the tuple args,
        and keyword arguments taken from the optional dictionary kwargs.
        Note that classes are callable, as are instances with a __call__() method.
        
        Deprecated since release 2.3. Instead, use the extended call syntax:
            function(*args, **keywords).
    
    callable(...)
        callable(object) -> bool
        
        Return whether the object is callable (i.e., some kind of function).
        Note that classes are callable, as are instances with a __call__() method.
    
    chr(...)
        chr(i) -> character
        
        Return a string of one character with ordinal i; 0 <= i < 256.
    
    cmp(...)
        cmp(x, y) -> integer
        
        Return negative if x<y, zero if x==y, positive if x>y.
    
    coerce(...)
        coerce(x, y) -> (x1, y1)
        
        Return a tuple consisting of the two numeric arguments converted to
        a common type, using the same rules as used by arithmetic operations.
        If coercion is not possible, raise TypeError.
    
    compile(...)
        compile(source, filename, mode[, flags[, dont_inherit]]) -> code object
        
        Compile the source string (a Python module, statement or expression)
        into a code object that can be executed by the exec statement or eval().
        The filename will be used for run-time error messages.
        The mode must be 'exec' to compile a module, 'single' to compile a
        single (interactive) statement, or 'eval' to compile an expression.
        The flags argument, if present, controls which future statements influence
        the compilation of the code.
        The dont_inherit argument, if non-zero, stops the compilation inheriting
        the effects of any future statements in effect in the code calling
        compile; if absent or zero these statements do influence the compilation,
        in addition to any features explicitly specified.
    
    delattr(...)
        delattr(object, name)
        
        Delete a named attribute on an object; delattr(x, 'y') is equivalent to
        ``del x.y''.
    
    dir(...)
        dir([object]) -> list of strings
        
        Return an alphabetized list of names comprising (some of) the attributes
        of the given object, and of attributes reachable from it:
        
        No argument:  the names in the current scope.
        Module object:  the module attributes.
        Type or class object:  its attributes, and recursively the attributes of
            its bases.
        Otherwise:  its attributes, its class's attributes, and recursively the
            attributes of its class's base classes.
    
    divmod(...)
        divmod(x, y) -> (div, mod)
        
        Return the tuple ((x-x%y)/y, x%y).  Invariant: div*y + mod == x.
    
    eval(...)
        eval(source[, globals[, locals]]) -> value
        
        Evaluate the source in the context of globals and locals.
        The source may be a string representing a Python expression
        or a code object as returned by compile().
        The globals must be a dictionary and locals can be any mapping,
        defaulting to the current globals and locals.
        If only globals is given, locals defaults to it.
    
    execfile(...)
        execfile(filename[, globals[, locals]])
        
        Read and execute a Python script from a file.
        The globals and locals are dictionaries, defaulting to the current
        globals and locals.  If only globals is given, locals defaults to it.
    
    filter(...)
        filter(function or None, sequence) -> list, tuple, or string
        
        Return those items of sequence for which function(item) is true.  If
        function is None, return the items that are true.  If sequence is a tuple
        or string, return the same type, else return a list.
    
    getattr(...)
        getattr(object, name[, default]) -> value
        
        Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.
        When a default argument is given, it is returned when the attribute doesn't
        exist; without it, an exception is raised in that case.
    
    globals(...)
        globals() -> dictionary
        
        Return the dictionary containing the current scope's global variables.
    
    hasattr(...)
        hasattr(object, name) -> bool
        
        Return whether the object has an attribute with the given name.
        (This is done by calling getattr(object, name) and catching exceptions.)
    
    hash(...)
        hash(object) -> integer
        
        Return a hash value for the object.  Two objects with the same value have
        the same hash value.  The reverse is not necessarily true, but likely.
    
    hex(...)
        hex(number) -> string
        
        Return the hexadecimal representation of an integer or long integer.
    
    id(...)
        id(object) -> integer
        
        Return the identity of an object.  This is guaranteed to be unique among
        simultaneously existing objects.  (Hint: it's the object's memory address.)
    
    input(...)
        input([prompt]) -> value
        
        Equivalent to eval(raw_input(prompt)).
    
    intern(...)
        intern(string) -> string
        
        ``Intern'' the given string.  This enters the string in the (global)
        table of interned strings whose purpose is to speed up dictionary lookups.
        Return the string itself or the previously interned string object with the
        same value.
    
    isinstance(...)
        isinstance(object, class-or-type-or-tuple) -> bool
        
        Return whether an object is an instance of a class or of a subclass thereof.
        With a type as second argument, return whether that is the object's type.
        The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for
        isinstance(x, A) or isinstance(x, B) or ... (etc.).
    
    issubclass(...)
        issubclass(C, B) -> bool
        
        Return whether class C is a subclass (i.e., a derived class) of class B.
        When using a tuple as the second argument issubclass(X, (A, B, ...)),
        is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).
    
    iter(...)
        iter(collection) -> iterator
        iter(callable, sentinel) -> iterator
        
        Get an iterator from an object.  In the first form, the argument must
        supply its own iterator, or be a sequence.
        In the second form, the callable is called until it returns the sentinel.
    
    len(...)
        len(object) -> integer
        
        Return the number of items of a sequence or mapping.
    
    locals(...)
        locals() -> dictionary
        
        Update and return a dictionary containing the current scope's local variables.
    
    map(...)
        map(function, sequence[, sequence, ...]) -> list
        
        Return a list of the results of applying the function to the items of
        the argument sequence(s).  If more than one sequence is given, the
        function is called with an argument list consisting of the corresponding
        item of each sequence, substituting None for missing values when not all
        sequences have the same length.  If the function is None, return a list of
        the items of the sequence (or a list of tuples if more than one sequence).
    
    max(...)
        max(iterable[, key=func]) -> value
        max(a, b, c, ...[, key=func]) -> value
        
        With a single iterable argument, return its largest item.
        With two or more arguments, return the largest argument.
    
    min(...)
        min(iterable[, key=func]) -> value
        min(a, b, c, ...[, key=func]) -> value
        
        With a single iterable argument, return its smallest item.
        With two or more arguments, return the smallest argument.
    
    oct(...)
        oct(number) -> string
        
        Return the octal representation of an integer or long integer.
    
    open(...)
        open(name[, mode[, buffering]]) -> file object
        
        Open a file using the file() type, returns a file object.
    
    ord(...)
        ord(c) -> integer
        
        Return the integer ordinal of a one-character string.
    
    pow(...)
        pow(x, y[, z]) -> number
        
        With two arguments, equivalent to x**y.  With three arguments,
        equivalent to (x**y) % z, but may be more efficient (e.g. for longs).
    
    range(...)
        range([start,] stop[, step]) -> list of integers
        
        Return a list containing an arithmetic progression of integers.
        range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
        When step is given, it specifies the increment (or decrement).
        For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
        These are exactly the valid indices for a list of 4 elements.
    
    raw_input(...)
        raw_input([prompt]) -> string
        
        Read a string from standard input.  The trailing newline is stripped.
        If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.
        On Unix, GNU readline is used if enabled.  The prompt string, if given,
        is printed without a trailing newline before reading.
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    
    reload(...)
        reload(module) -> module
        
        Reload the module.  The module must have been successfully imported before.
    
    repr(...)
        repr(object) -> string
        
        Return the canonical string representation of the object.
        For most object types, eval(repr(object)) == object.
    
    round(...)
        round(number[, ndigits]) -> floating point number
        
        Round a number to a given precision in decimal digits (default 0 digits).
        This always returns a floating point number.  Precision may be negative.
    
    setattr(...)
        setattr(object, name, value)
        
        Set a named attribute on an object; setattr(x, 'y', v) is equivalent to
        ``x.y = v''.
    
    sorted(...)
        sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
    
    sum(...)
        sum(sequence, start=0) -> value
        
        Returns the sum of a sequence of numbers (NOT strings) plus the value
        of parameter 'start'.  When the sequence is empty, returns start.
    
    unichr(...)
        unichr(i) -> Unicode character
        
        Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.
    
    vars(...)
        vars([object]) -> dictionary
        
        Without arguments, equivalent to locals().
        With an argument, equivalent to object.__dict__.
    
    zip(...)
        zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]
        
        Return a list of tuples, where each tuple contains the i-th element
        from each of the argument sequences.  The returned list is truncated
        in length to the length of the shortest argument sequence.